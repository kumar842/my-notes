~~~~~~~   Javascript basics   ~~~~~~~ 
Javascript:
- client-side programming language
- NodeJs - server side programming language
- Interpreted & loosely typed language

var
const
let

literal

typeof - both operator & function

Number - Number(undefined) -> NaN, Number('  ') -> 0
String
prompt, confirm
console.log
alert
use strict ??


operators:
	Assignment: = as in a = 2.
	Math: + - * / %
	Compound Assignment: +=, -=, *=, and /=
	Increment/Decrement: ++, --
	Object Property Access: . as in console.log().

	Objects are values that hold other values at specific named locations called properties. obj.a means an object value called obj with a property of the name a. Properties can alternatively be accessed as obj["a"]. See Chapter 2.

	Equality: == (loose-equals), === (strict-equals), != (loose not-equals), !== (strict not-equals)
	Comparison: <, >, <=, >=
	Logical && ||
		var a = {}
		var b = a.id || 100. //100	

data types: number, string, boolean, function, object
	- number: 1, 2.0, Infinity, -Infinity, NaN
	- string: "", ''
	- boolean: true, false 
	- object: {}, [], [1,2], Math
	- function: isEven, Number, alert, 
	- undefined: typeof(undefined) -> undefined
	- Symbol for unique identifiers.
	- null - reference to a non-existing object - typeof(null) -> object
			The result of typeof null is "object". That’s wrong. It is an officially recognized error in typeof, kept for compatibility. Of course, null is not an object. It is a special value with a separate type of its own. So, again, this is an error in the language.

Type Conversions:
	- Number('') -> 0, Number('  ') -> 0, Number(undefined) -> NaN, Number(null) -> 0, 
		- ''        = 0
		- '  '      = 0
		- undefined = NaN
		- true, false = 1, 0
		- non-empty string = NaN
		- + short form of Number()
			- +true -> 1, +"". -> 0	
			- -"12" -> -12.  -''  -> 0


	- String
		- 123 ->"123"
		- 2.2 -> "2.2"
		- null -> "null"
		- undefined -> "undefined"
		- isEven -> "(n) => n %2 === 0"

	- Boolean
		- 0, null, undefined, NaN, '' -> false
		- any other value = true


Evaluation: 
1 + 2 + '3'    -> "33"
'1' + 2 + 3    -> "123"
"" + 1 + 0     -> "10"
"" - 1 + 0     -> -1
true + false   -> 1
6 / "3"        -> 2
"2" * "3"      -> 6
4 + 5 + "px"   -> "9px"
"$" + 4 + 5    -> "$45"
"4" - 2        -> 2
"4px" - 2      -> NaN
7 / 0          -> Infinity
"  -9  " + 5   -> "  -9  5"
"  -9  " - 5   -> -14
null + 1       -> 1
undefined + 1  -> NaN


215.9784
amount.toFixed( 2 )  -> 215.98


~~~~~~~     ES6 Features. ~~~~~~~ 
1. Declearing Variables in ES6
	- const
	- let
	- Template Strings
	- Default parameters

2. Arrow Functions
3. Transpiling ES6 to ES5
	- Babel - one of the popular tools
	- Transpiling is not compiling: our code isn’t compiled to binary. Instead, it’s transpiled into syntax that can be interpreted by a wider range of browsers. 
-------------------------------------------------
const add = (x=5, y=10) => console.log(x+y);

"use strict";
var add = function add() {
	var x = arguments.length <= 0 || arguments[0] === undefined ? 5 : arguments[0];
	var y = arguments.length <= 1 || arguments[1] === undefined ? 10 : arguments[1];
	return console.log(x + y);
};
-------------------------------------------------
//Transpiling in the Browser:
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.js">
</script>
<script src="script.js" type="text/babel"> </script>
-------------------------------------------------
This approach means that the browser does the transpiling at run‐ time. This is not a good idea for production because it will slow your application down a lot. In Chapter 5, we’ll go over how to do this in production. For now, the CDN link will allow us to discover and use ES6 features.


4. ES6 Objects & Arrays
	- Destructuring Assignment
	- Object Literal Enhancement
	- The Spread Operator
	- Promises
	- Classes
	- ES6 Modules
	- CommonJS


The reverse function has actually alters or mutates the array


~~~~~~~  Functional Programming with JavaScript ~~~~~~~ 
- map, reduce
- React, Flux & Redux
- Functions can be sent to functions as arguments or returned from functions as results.
- 17th century - lambda calculus, or λ-calculus
- 1930s - Alonzo Church was at Princeton experimenting with these higher-order functions when he invented lambda calculus.

- 1950 - John McCarthy - a new programming language called Lisp
- Functions as first-class members/citizens
- A function is considered a first-class member when it can be declared as a variable, sent to functions as an argument and can even be returned from functions.

- In JavaScript, functions can represent data in your application.

var log = function(message) { console.log(message) };
const log = message => console.log(message)
log('.......')

// In JavaScript, functions are variables
// They can be added to objects like variables
// They can be inserted into arrays like variables
// They can be sent to other functions as arguments
// FUNCTIONS CAN BE RETURNED FROM OTHER FUNCTIONS!!!





Javascripts Good parts:
----------------------------------------------------------------------
A controversial feature in JavaScript is prototypal inheritance. JavaScript has a class-free object system in which objects inherit properties directly from other objects. This is really powerful, but it is unfamiliar to classically trained programmers. If you attempt to apply classical design patterns directly to JavaScript, you will be frustrated. But if you learn to work with JavaScript's prototypal nature, your efforts will be rewarded.


falsy values:
. false
· null
· undefined
· The empty string ''
· The number 0
· The number NaN


for (myvar in obj) {
	if (obj.hasownProperty(myvar)) {
	...
	}
}

switch - case , do-while, while
try - catch - throw - throws - finally 
enum
The simplest expressions are a literal value (such as a string or number), a variable, a built-in value (true, false, null, undefined, NaN, or Infinity), an invocation expression preceded by new, a refinement expression preceded by delete,

typeof - nubmer, string, boolean, undefined, funtion, object
to number 
negate 
logical not 

typeof(arrya) = object
typeof(null) = object 

literals - number, string, object, array, function, regexp
Numbers, strings, and booleans are object-like in that they have methods, but they are immutable.
objects - mutable keyed collections. arrays, functions, regexpressions, objects 

An object is a container of properties, where a property has a name and a value. A property name can be any string, including the empty string. A property value can be any JavaScript value except for undefined.


Objects in JavaScript are class-free. There is no constraint on the names of new properties or on the values of properties. Objects are useful for collecting and organizing data. Objects can contain other objects, so they can easily represent tree or graph structures.

JavaScript includes a prototype linkage feature that allows one object to inherit the properties of another. When used well, this can reduce object initialization time and memory consumption.

var empty_object = {};
var person = {name: "Raj"};
Object properties

stooge["first-name"] // "Joe"
flight.departure.IATA // "SYD"

The undefined value is produced if an attempt is made to retrieve a nonexistent member:
stooge["middle-name"] // undefined
flight.status // undefined
stooge["FIRST-NAME"] // undefined
The || operator can be used to fill in default values:
var middle = stooge["middle-name"] || "(none)";
var status = flight.status || "unknown";
Attempting to retrieve values from undefined will throw a TypeError exception. This can be guarded
against with the && operator:
flight.equipment // undefined
flight.equipment.model // throw "TypeError"
flight.equipment && flight.equipment.model // undefined



var a = {}, b = {}, c = {};
// a, b, and c each refer to a
// different empty object
a = b = c = {};
// a, b, and c all refer to
// the same empty object




The other approach is to use the hasOwnProperty method, which returns true if the object has a
particular property. The hasOwnProperty method does not look at the prototype chain:
flight.hasOwnProperty('number') // true
flight.hasOwnProperty('constructor') // false



A function encloses a set of statements. Functions are the fundamental modular unit of JavaScript. They are
used for code reuse, information hiding, and composition. Functions are used to specify the behavior of
objects. Generally, the craft of programming is the factoring of a set of requirements into a set of functions
and data structures.


Functions in JavaScript are objects. Objects are collections of name/value pairs having a hidden link to a
prototype object. Objects produced from object literals are linked to Object.prototype. Function objects
are linked to Function.prototype (which is itself linked to Object.prototype). Every function is
also created with two additional hidden properties: the function's context and the code that implements the
function's behavior.

function literal 
var add = function (a, b) {
return a + b;
};

- keyword function 
- name 
- parameters
- set of statements


A function literal can appear anywhere that an expression can appear. Functions can be defined inside of other
functions. An inner function of course has access to its parameters and variables. An inner function also
enjoys access to the parameters and variables of the functions it is nested within. The function object created
by a function literal contains a link to that outer context. This is called closure. This is the source of enormous
expressive power.


In addition to the declared parameters, every function receives two additional parameters: this and
arguments. The this parameter is very important in object oriented programming, and its value is
determined by the invocation pattern. There are four patterns of invocation in JavaScript: the method
invocation pattern, the function invocation pattern, the constructor invocation pattern, and the apply
invocation pattern. The patterns differ in how the bonus parameter this is initialized



The invocation operator is a pair of parentheses that follow any expression that produces a function value. The
parentheses can contain zero or more expressions, separated by commas. Each expression produces one
argument value. Each of the argument values will be assigned to the function's parameter names. There is no
runtime error when the number of arguments and the number of parameters do not match. If there are too
many argument values, the extra argument values will be ignored. If there are too few argument values, the
undefined value will be substituted for the missing values. There is no type checking on the argument
values: any type of value can be passed to any parameter.


clarity
--------------------------------------------------------------
==     ===
prototype








Floating point arithmetic is not always 100% accurate.
